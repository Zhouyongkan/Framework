

**1**、**服务端基本配置**:

​      设置一个工程目录:

​			多文件结构,一个是目标文件(include)存放所有头文件一个是源文件(src)存放所有源文件。
​			common.mk装的是makefile的模板,子目录的所有makefile引用这个模板

​      设置配置文件:

​			做配置文件，key=val形式，#【 ；都认为是注释
​			把key-value信息读取到内存当中，一上来全局变量（链表）抓住所有配置信息。
​			读取配置型两种格式，一种是字符串，一种是数字			

​			在程序启动时,就将所有配置信息加载到内存(链表储存)。
​	        加载完配置信息后，(对字符类型进行处理后)将所有的字符类型配置和整数类型配置插入到链表中，读取配置项时都通过链表进行读取。
​	     
​      配置环境变量:

​			为了给每个子进程设置名字，将给的新名字设置到命令行参数位置。(命令行参数和环境变量末尾是NULL)
​            这样有可能导致命令行参数太长，破坏环境变量(参考PCB内核空间)所以要给环境变量搬家(将环境变量搬到堆上去)。
​                     
信号处理:先对信号进行初始化，不同的信号有不同的处理，经过命令找到信号，通过信号执行信号对应的回调函数。

      多进程模型:
​         父进程创建一批子进程后进入死循环,子进程进行一系列初始化之后也进入死循环。
​	 	主进程创建子进程,在创建子进程之前要进行信号屏蔽，避免在创建子进程期间被打断。创建完子进程,主进程进入死循环,调用sigsuspend函数(用自己的信号屏蔽集，相当于解除其他信号屏蔽,只有在sigsuspend函数运行期间，之后回切回到原来的信号屏蔽)，进行阻塞，直到有信号来才被唤醒，才会做后面的事情。(信号驱动工作模型)
​	      创建出来的子进程进行初始化:设置子进程标题,因为子进程继承了父进程的信号屏蔽,所以要解除信号屏蔽。
​          为了提高cpu的工作效率,设置cpu亲和：将每个进程绑定到指定的cpu上去。(防止进程随机在各个CPU上跑，导致不停的覆盖缓存,降低效率)。cat proc/cpuinfo查看处理器
​			ps -eo pid, psr,tty,command,args查看在那个处理器上
​          初始化完之后子进程阻塞在epoll_wait等待连接。
​	       可以设置进程以守护进程方式启动。
​	     （附加:是否要以守护进程启动？(fork出子进程然后创建出新的session.))
​	       (如果想让某个进程不因为用户或终端或其他地变化而受到影响，那么就可以把这个进程变成一个守护进程)
​	       (为什么要用守护进程:每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。但是守护进程却能够突破这种限制，它从被执行开始运转，直到整个系统关闭时才退出。)

**2、业务管理**:   解析数据、处理数据、封装发送数据。
	采用线程池:
		初始化任务队列节点、线程池结构体。
		将任务添加到任务队列中,如果有空闲线程,就唤醒线程,直接去回调这个任务。如果没有，并且当前的线程数没有达到最大值,就创建新的线程来执行任务。
		空闲线程在等待任务信号的过程中阻塞,当从任务队列中摘取任务项目后，将任务项目放到线程中，开始执行任务。
		执行任务回调函数中,调用callback执行可能时间比较长，可以给他解锁，不解锁线程池只有一个线程执行任务，如果时间很长会影响其他线程去执行任务。之前上锁是怕生产者和消费者都去操纵他，而现在将他从任务队列当中取出来了，就不怕了。所以解锁不会有问题。
		销毁线程池:要等待所有线程处理完任务后，再销毁线程(即将quit标志置位1)。因为所有空闲线程会阻塞在等待任务队列中,当空闲线程大于0时调用pthread_cond_broadcast去通知所有空闲线程进行销毁。
	    而当还有线程在执行任务时,进行pthread_cond_wait阻塞,直到收到所有线程都销毁了的信号之后，才离开。

问题：如果线程池中空闲线程长时间没有执行任务可以将其销毁

![](C:\Users\Lenovo\Desktop\线程池.png)

**3、网络管理**:     接受网络数据、发送数据包
	 采用epoll方式处理:(将阻塞和等待进行分离更好)

​				运用epoll_create\epoll_ctl\epoll_wait来完成文件描述符的维护和监听，并且存储准备就绪的事件。为了实现与业务层处理进行异步化(网络层负责数据接收，业务管理中线程池只负责处理数据，所以两者之间都需要知道那个描述符，线程池需要知道是哪个已连接套接字的，网络将文件描述符以及数据要传给线程池，处理读还是处理写；最后返回时也要告诉网络层是哪个)，设计了一个连接池(数组方式存储)。

​                定义一个结构体包含已就绪的文件描述符和其对应的数据，将这个结构体放入到连接池数组中，要知道哪些是空闲的，那些是已经被使用的；将所有没有使用的用链表连起来。线程池就可以从这个连接池中拿到套接字对应的结构体，然后进行业务处理操作

​				先完成监听套接字初始化工作，执行epoll_init创建epoll句柄，然后初始化连接池(先将所有结构体中的所有fd置为-1表示空闲连接，并且用指针将所有结构体链接起来.)初始完后，给监听套接字分配连接池节点、设置监听套接字对应的回调函数，再将事件加入到epoll红黑树中。加入过程，判断是读将标记是epollin，也将连接池中记录当前状态置为一样，返回时拿到对应连接池指针信息，这时什么信息都有了。然后再加入红黑树中。

​				读处理粘包问题没处理；

​				数据读取到，并且装到了buffer(读取缓冲区)中，将任务放到线程池中去处理。处理完成后还是epollin状态，要进行发送数据，需要改变状态。如果对方关闭，从红黑树删除，归还连接池节点。

​				监听写事件时，等线程池处理完事件后，再加入到epoll红黑树上去，让epoll帮我们去监控写事件。如果数据一读，立马去监控写事件，如果内核缓存有空间立马触发epollwait返回，而这时候数据还没有处理好，就会不断触发epoll_wait返回很浪费;第二个方案，当数据处理完成直接发送数据，如果一次发送不完，再将它加入到红黑树中。

​				获取发生事件：没有做超时处理，进行阻塞epoll_wait，如果返回就代表有事件就绪

​				数据包大小是2000写死了，没有写动态内存分配。

**4、数据库访问层**

​				若执行任务时,要访问数据库，则需要连接数据库查询数据。因为与数据库连接需要建立TCP连接，而每次TCP连接都要进行三次握手、四次挥手，耗费大量时间。所以建立一个连接池来优化(可以规定最多有多少个线程访问数据库)。

​				连接池:(减少三次握手、四次挥手。减少数据库的权限检查。)

​				1.封装连接池访问数据库要调用的函数:

​								int connection连接数据库(内部使用mysql_real_connect函数),int update插入数据,MYSQL_RES *query查询数据。

​				2.初始化连接队列节点、连接池结构体。封装连接池初始化函数和向连接池添加任务函数。

​				3.如果pool->head不为null证明有空闲连接，取下连接节点，执行对应数据库的sql语句。如果为null但是最大连接数没到最大值，则创建新的连接，并且直接执行sql，再插入到连接队列中。如果超过最大值并且没有空闲连接了，就进行pthread_cond_wait。直到有空闲连接返回，被换新然后取下连接执行任务。

​				

